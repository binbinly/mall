// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"project-layout/internal/model"
)

func newOmsPayment(db *gorm.DB, opts ...gen.DOOption) omsPayment {
	_omsPayment := omsPayment{}

	_omsPayment.omsPaymentDo.UseDB(db, opts...)
	_omsPayment.omsPaymentDo.UseModel(&model.OmsPayment{})

	tableName := _omsPayment.omsPaymentDo.TableName()
	_omsPayment.ALL = field.NewAsterisk(tableName)
	_omsPayment.ID = field.NewInt(tableName, "id")
	_omsPayment.OrderID = field.NewInt64(tableName, "order_id")
	_omsPayment.OrderNo = field.NewString(tableName, "order_no")
	_omsPayment.TradeNo = field.NewString(tableName, "trade_no")
	_omsPayment.Amount = field.NewInt64(tableName, "amount")
	_omsPayment.Subject = field.NewString(tableName, "subject")
	_omsPayment.ConfirmAt = field.NewInt64(tableName, "confirm_at")
	_omsPayment.CallbackContent = field.NewString(tableName, "callback_content")
	_omsPayment.CallbackAt = field.NewInt64(tableName, "callback_at")
	_omsPayment.CreatedAt = field.NewInt(tableName, "created_at")
	_omsPayment.UpdatedAt = field.NewInt(tableName, "updated_at")

	_omsPayment.fillFieldMap()

	return _omsPayment
}

type omsPayment struct {
	omsPaymentDo

	ALL             field.Asterisk
	ID              field.Int    // ID
	OrderID         field.Int64  // 订单id
	OrderNo         field.String // 订单号
	TradeNo         field.String // 交易号
	Amount          field.Int64  // 交易金额/分
	Subject         field.String // 交易内容
	ConfirmAt       field.Int64  // 确认时间
	CallbackContent field.String // 回调内容
	CallbackAt      field.Int64  // 回调时间
	CreatedAt       field.Int    // 创建时间
	UpdatedAt       field.Int    // 更新时间

	fieldMap map[string]field.Expr
}

func (o omsPayment) Table(newTableName string) *omsPayment {
	o.omsPaymentDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o omsPayment) As(alias string) *omsPayment {
	o.omsPaymentDo.DO = *(o.omsPaymentDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *omsPayment) updateTableName(table string) *omsPayment {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt(table, "id")
	o.OrderID = field.NewInt64(table, "order_id")
	o.OrderNo = field.NewString(table, "order_no")
	o.TradeNo = field.NewString(table, "trade_no")
	o.Amount = field.NewInt64(table, "amount")
	o.Subject = field.NewString(table, "subject")
	o.ConfirmAt = field.NewInt64(table, "confirm_at")
	o.CallbackContent = field.NewString(table, "callback_content")
	o.CallbackAt = field.NewInt64(table, "callback_at")
	o.CreatedAt = field.NewInt(table, "created_at")
	o.UpdatedAt = field.NewInt(table, "updated_at")

	o.fillFieldMap()

	return o
}

func (o *omsPayment) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *omsPayment) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 11)
	o.fieldMap["id"] = o.ID
	o.fieldMap["order_id"] = o.OrderID
	o.fieldMap["order_no"] = o.OrderNo
	o.fieldMap["trade_no"] = o.TradeNo
	o.fieldMap["amount"] = o.Amount
	o.fieldMap["subject"] = o.Subject
	o.fieldMap["confirm_at"] = o.ConfirmAt
	o.fieldMap["callback_content"] = o.CallbackContent
	o.fieldMap["callback_at"] = o.CallbackAt
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
}

func (o omsPayment) clone(db *gorm.DB) omsPayment {
	o.omsPaymentDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o omsPayment) replaceDB(db *gorm.DB) omsPayment {
	o.omsPaymentDo.ReplaceDB(db)
	return o
}

type omsPaymentDo struct{ gen.DO }

type IOmsPaymentDo interface {
	gen.SubQuery
	Debug() IOmsPaymentDo
	WithContext(ctx context.Context) IOmsPaymentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOmsPaymentDo
	WriteDB() IOmsPaymentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOmsPaymentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOmsPaymentDo
	Not(conds ...gen.Condition) IOmsPaymentDo
	Or(conds ...gen.Condition) IOmsPaymentDo
	Select(conds ...field.Expr) IOmsPaymentDo
	Where(conds ...gen.Condition) IOmsPaymentDo
	Order(conds ...field.Expr) IOmsPaymentDo
	Distinct(cols ...field.Expr) IOmsPaymentDo
	Omit(cols ...field.Expr) IOmsPaymentDo
	Join(table schema.Tabler, on ...field.Expr) IOmsPaymentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOmsPaymentDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOmsPaymentDo
	Group(cols ...field.Expr) IOmsPaymentDo
	Having(conds ...gen.Condition) IOmsPaymentDo
	Limit(limit int) IOmsPaymentDo
	Offset(offset int) IOmsPaymentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOmsPaymentDo
	Unscoped() IOmsPaymentDo
	Create(values ...*model.OmsPayment) error
	CreateInBatches(values []*model.OmsPayment, batchSize int) error
	Save(values ...*model.OmsPayment) error
	First() (*model.OmsPayment, error)
	Take() (*model.OmsPayment, error)
	Last() (*model.OmsPayment, error)
	Find() ([]*model.OmsPayment, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OmsPayment, err error)
	FindInBatches(result *[]*model.OmsPayment, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OmsPayment) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOmsPaymentDo
	Assign(attrs ...field.AssignExpr) IOmsPaymentDo
	Joins(fields ...field.RelationField) IOmsPaymentDo
	Preload(fields ...field.RelationField) IOmsPaymentDo
	FirstOrInit() (*model.OmsPayment, error)
	FirstOrCreate() (*model.OmsPayment, error)
	FindByPage(offset int, limit int) (result []*model.OmsPayment, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOmsPaymentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o omsPaymentDo) Debug() IOmsPaymentDo {
	return o.withDO(o.DO.Debug())
}

func (o omsPaymentDo) WithContext(ctx context.Context) IOmsPaymentDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o omsPaymentDo) ReadDB() IOmsPaymentDo {
	return o.Clauses(dbresolver.Read)
}

func (o omsPaymentDo) WriteDB() IOmsPaymentDo {
	return o.Clauses(dbresolver.Write)
}

func (o omsPaymentDo) Session(config *gorm.Session) IOmsPaymentDo {
	return o.withDO(o.DO.Session(config))
}

func (o omsPaymentDo) Clauses(conds ...clause.Expression) IOmsPaymentDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o omsPaymentDo) Returning(value interface{}, columns ...string) IOmsPaymentDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o omsPaymentDo) Not(conds ...gen.Condition) IOmsPaymentDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o omsPaymentDo) Or(conds ...gen.Condition) IOmsPaymentDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o omsPaymentDo) Select(conds ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o omsPaymentDo) Where(conds ...gen.Condition) IOmsPaymentDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o omsPaymentDo) Order(conds ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o omsPaymentDo) Distinct(cols ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o omsPaymentDo) Omit(cols ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o omsPaymentDo) Join(table schema.Tabler, on ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o omsPaymentDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o omsPaymentDo) RightJoin(table schema.Tabler, on ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o omsPaymentDo) Group(cols ...field.Expr) IOmsPaymentDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o omsPaymentDo) Having(conds ...gen.Condition) IOmsPaymentDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o omsPaymentDo) Limit(limit int) IOmsPaymentDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o omsPaymentDo) Offset(offset int) IOmsPaymentDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o omsPaymentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOmsPaymentDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o omsPaymentDo) Unscoped() IOmsPaymentDo {
	return o.withDO(o.DO.Unscoped())
}

func (o omsPaymentDo) Create(values ...*model.OmsPayment) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o omsPaymentDo) CreateInBatches(values []*model.OmsPayment, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o omsPaymentDo) Save(values ...*model.OmsPayment) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o omsPaymentDo) First() (*model.OmsPayment, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OmsPayment), nil
	}
}

func (o omsPaymentDo) Take() (*model.OmsPayment, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OmsPayment), nil
	}
}

func (o omsPaymentDo) Last() (*model.OmsPayment, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OmsPayment), nil
	}
}

func (o omsPaymentDo) Find() ([]*model.OmsPayment, error) {
	result, err := o.DO.Find()
	return result.([]*model.OmsPayment), err
}

func (o omsPaymentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OmsPayment, err error) {
	buf := make([]*model.OmsPayment, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o omsPaymentDo) FindInBatches(result *[]*model.OmsPayment, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o omsPaymentDo) Attrs(attrs ...field.AssignExpr) IOmsPaymentDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o omsPaymentDo) Assign(attrs ...field.AssignExpr) IOmsPaymentDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o omsPaymentDo) Joins(fields ...field.RelationField) IOmsPaymentDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o omsPaymentDo) Preload(fields ...field.RelationField) IOmsPaymentDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o omsPaymentDo) FirstOrInit() (*model.OmsPayment, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OmsPayment), nil
	}
}

func (o omsPaymentDo) FirstOrCreate() (*model.OmsPayment, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OmsPayment), nil
	}
}

func (o omsPaymentDo) FindByPage(offset int, limit int) (result []*model.OmsPayment, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o omsPaymentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o omsPaymentDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o omsPaymentDo) Delete(models ...*model.OmsPayment) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *omsPaymentDo) withDO(do gen.Dao) *omsPaymentDo {
	o.DO = *do.(*gen.DO)
	return o
}
