// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"project-layout/internal/model"
)

func newUmsMember(db *gorm.DB, opts ...gen.DOOption) umsMember {
	_umsMember := umsMember{}

	_umsMember.umsMemberDo.UseDB(db, opts...)
	_umsMember.umsMemberDo.UseModel(&model.UmsMember{})

	tableName := _umsMember.umsMemberDo.TableName()
	_umsMember.ALL = field.NewAsterisk(tableName)
	_umsMember.ID = field.NewInt(tableName, "id")
	_umsMember.LevelID = field.NewInt(tableName, "level_id")
	_umsMember.Username = field.NewString(tableName, "username")
	_umsMember.Nickname = field.NewString(tableName, "nickname")
	_umsMember.Password = field.NewString(tableName, "password")
	_umsMember.Phone = field.NewInt64(tableName, "phone")
	_umsMember.Email = field.NewString(tableName, "email")
	_umsMember.Avatar = field.NewString(tableName, "avatar")
	_umsMember.Gender = field.NewInt8(tableName, "gender")
	_umsMember.Birth = field.NewTime(tableName, "birth")
	_umsMember.Area = field.NewString(tableName, "area")
	_umsMember.Job = field.NewString(tableName, "job")
	_umsMember.SourceType = field.NewInt8(tableName, "source_type")
	_umsMember.Integration = field.NewInt64(tableName, "integration")
	_umsMember.Growth = field.NewInt64(tableName, "growth")
	_umsMember.Status = field.NewInt8(tableName, "status")
	_umsMember.Sign = field.NewString(tableName, "sign")
	_umsMember.CreatedAt = field.NewTime(tableName, "created_at")
	_umsMember.UpdatedAt = field.NewTime(tableName, "updated_at")
	_umsMember.DeletedAt = field.NewField(tableName, "deleted_at")

	_umsMember.fillFieldMap()

	return _umsMember
}

type umsMember struct {
	umsMemberDo

	ALL         field.Asterisk
	ID          field.Int    // ID
	LevelID     field.Int    // 会员等级id
	Username    field.String // 用户名
	Nickname    field.String // 昵称
	Password    field.String // 密码
	Phone       field.Int64  // 手机号
	Email       field.String // 邮箱
	Avatar      field.String // 头像
	Gender      field.Int8   // 性别
	Birth       field.Time   // 生日
	Area        field.String // 城市
	Job         field.String // 职业
	SourceType  field.Int8   // 用户来源
	Integration field.Int64  // 积分
	Growth      field.Int64  // 成长值
	Status      field.Int8   // 状态
	Sign        field.String // 签名
	CreatedAt   field.Time   // 创建时间
	UpdatedAt   field.Time   // 更新时间
	DeletedAt   field.Field  // 删除时间

	fieldMap map[string]field.Expr
}

func (u umsMember) Table(newTableName string) *umsMember {
	u.umsMemberDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u umsMember) As(alias string) *umsMember {
	u.umsMemberDo.DO = *(u.umsMemberDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *umsMember) updateTableName(table string) *umsMember {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt(table, "id")
	u.LevelID = field.NewInt(table, "level_id")
	u.Username = field.NewString(table, "username")
	u.Nickname = field.NewString(table, "nickname")
	u.Password = field.NewString(table, "password")
	u.Phone = field.NewInt64(table, "phone")
	u.Email = field.NewString(table, "email")
	u.Avatar = field.NewString(table, "avatar")
	u.Gender = field.NewInt8(table, "gender")
	u.Birth = field.NewTime(table, "birth")
	u.Area = field.NewString(table, "area")
	u.Job = field.NewString(table, "job")
	u.SourceType = field.NewInt8(table, "source_type")
	u.Integration = field.NewInt64(table, "integration")
	u.Growth = field.NewInt64(table, "growth")
	u.Status = field.NewInt8(table, "status")
	u.Sign = field.NewString(table, "sign")
	u.CreatedAt = field.NewTime(table, "created_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")
	u.DeletedAt = field.NewField(table, "deleted_at")

	u.fillFieldMap()

	return u
}

func (u *umsMember) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *umsMember) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 20)
	u.fieldMap["id"] = u.ID
	u.fieldMap["level_id"] = u.LevelID
	u.fieldMap["username"] = u.Username
	u.fieldMap["nickname"] = u.Nickname
	u.fieldMap["password"] = u.Password
	u.fieldMap["phone"] = u.Phone
	u.fieldMap["email"] = u.Email
	u.fieldMap["avatar"] = u.Avatar
	u.fieldMap["gender"] = u.Gender
	u.fieldMap["birth"] = u.Birth
	u.fieldMap["area"] = u.Area
	u.fieldMap["job"] = u.Job
	u.fieldMap["source_type"] = u.SourceType
	u.fieldMap["integration"] = u.Integration
	u.fieldMap["growth"] = u.Growth
	u.fieldMap["status"] = u.Status
	u.fieldMap["sign"] = u.Sign
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["deleted_at"] = u.DeletedAt
}

func (u umsMember) clone(db *gorm.DB) umsMember {
	u.umsMemberDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u umsMember) replaceDB(db *gorm.DB) umsMember {
	u.umsMemberDo.ReplaceDB(db)
	return u
}

type umsMemberDo struct{ gen.DO }

type IUmsMemberDo interface {
	gen.SubQuery
	Debug() IUmsMemberDo
	WithContext(ctx context.Context) IUmsMemberDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUmsMemberDo
	WriteDB() IUmsMemberDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUmsMemberDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUmsMemberDo
	Not(conds ...gen.Condition) IUmsMemberDo
	Or(conds ...gen.Condition) IUmsMemberDo
	Select(conds ...field.Expr) IUmsMemberDo
	Where(conds ...gen.Condition) IUmsMemberDo
	Order(conds ...field.Expr) IUmsMemberDo
	Distinct(cols ...field.Expr) IUmsMemberDo
	Omit(cols ...field.Expr) IUmsMemberDo
	Join(table schema.Tabler, on ...field.Expr) IUmsMemberDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUmsMemberDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUmsMemberDo
	Group(cols ...field.Expr) IUmsMemberDo
	Having(conds ...gen.Condition) IUmsMemberDo
	Limit(limit int) IUmsMemberDo
	Offset(offset int) IUmsMemberDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUmsMemberDo
	Unscoped() IUmsMemberDo
	Create(values ...*model.UmsMember) error
	CreateInBatches(values []*model.UmsMember, batchSize int) error
	Save(values ...*model.UmsMember) error
	First() (*model.UmsMember, error)
	Take() (*model.UmsMember, error)
	Last() (*model.UmsMember, error)
	Find() ([]*model.UmsMember, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UmsMember, err error)
	FindInBatches(result *[]*model.UmsMember, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UmsMember) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUmsMemberDo
	Assign(attrs ...field.AssignExpr) IUmsMemberDo
	Joins(fields ...field.RelationField) IUmsMemberDo
	Preload(fields ...field.RelationField) IUmsMemberDo
	FirstOrInit() (*model.UmsMember, error)
	FirstOrCreate() (*model.UmsMember, error)
	FindByPage(offset int, limit int) (result []*model.UmsMember, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUmsMemberDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u umsMemberDo) Debug() IUmsMemberDo {
	return u.withDO(u.DO.Debug())
}

func (u umsMemberDo) WithContext(ctx context.Context) IUmsMemberDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u umsMemberDo) ReadDB() IUmsMemberDo {
	return u.Clauses(dbresolver.Read)
}

func (u umsMemberDo) WriteDB() IUmsMemberDo {
	return u.Clauses(dbresolver.Write)
}

func (u umsMemberDo) Session(config *gorm.Session) IUmsMemberDo {
	return u.withDO(u.DO.Session(config))
}

func (u umsMemberDo) Clauses(conds ...clause.Expression) IUmsMemberDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u umsMemberDo) Returning(value interface{}, columns ...string) IUmsMemberDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u umsMemberDo) Not(conds ...gen.Condition) IUmsMemberDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u umsMemberDo) Or(conds ...gen.Condition) IUmsMemberDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u umsMemberDo) Select(conds ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u umsMemberDo) Where(conds ...gen.Condition) IUmsMemberDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u umsMemberDo) Order(conds ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u umsMemberDo) Distinct(cols ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u umsMemberDo) Omit(cols ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u umsMemberDo) Join(table schema.Tabler, on ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u umsMemberDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u umsMemberDo) RightJoin(table schema.Tabler, on ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u umsMemberDo) Group(cols ...field.Expr) IUmsMemberDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u umsMemberDo) Having(conds ...gen.Condition) IUmsMemberDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u umsMemberDo) Limit(limit int) IUmsMemberDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u umsMemberDo) Offset(offset int) IUmsMemberDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u umsMemberDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUmsMemberDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u umsMemberDo) Unscoped() IUmsMemberDo {
	return u.withDO(u.DO.Unscoped())
}

func (u umsMemberDo) Create(values ...*model.UmsMember) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u umsMemberDo) CreateInBatches(values []*model.UmsMember, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u umsMemberDo) Save(values ...*model.UmsMember) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u umsMemberDo) First() (*model.UmsMember, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UmsMember), nil
	}
}

func (u umsMemberDo) Take() (*model.UmsMember, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UmsMember), nil
	}
}

func (u umsMemberDo) Last() (*model.UmsMember, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UmsMember), nil
	}
}

func (u umsMemberDo) Find() ([]*model.UmsMember, error) {
	result, err := u.DO.Find()
	return result.([]*model.UmsMember), err
}

func (u umsMemberDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UmsMember, err error) {
	buf := make([]*model.UmsMember, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u umsMemberDo) FindInBatches(result *[]*model.UmsMember, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u umsMemberDo) Attrs(attrs ...field.AssignExpr) IUmsMemberDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u umsMemberDo) Assign(attrs ...field.AssignExpr) IUmsMemberDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u umsMemberDo) Joins(fields ...field.RelationField) IUmsMemberDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u umsMemberDo) Preload(fields ...field.RelationField) IUmsMemberDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u umsMemberDo) FirstOrInit() (*model.UmsMember, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UmsMember), nil
	}
}

func (u umsMemberDo) FirstOrCreate() (*model.UmsMember, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UmsMember), nil
	}
}

func (u umsMemberDo) FindByPage(offset int, limit int) (result []*model.UmsMember, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u umsMemberDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u umsMemberDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u umsMemberDo) Delete(models ...*model.UmsMember) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *umsMemberDo) withDO(do gen.Dao) *umsMemberDo {
	u.DO = *do.(*gen.DO)
	return u
}
