// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"project-layout/internal/model"
)

func newSmsMemberPrice(db *gorm.DB, opts ...gen.DOOption) smsMemberPrice {
	_smsMemberPrice := smsMemberPrice{}

	_smsMemberPrice.smsMemberPriceDo.UseDB(db, opts...)
	_smsMemberPrice.smsMemberPriceDo.UseModel(&model.SmsMemberPrice{})

	tableName := _smsMemberPrice.smsMemberPriceDo.TableName()
	_smsMemberPrice.ALL = field.NewAsterisk(tableName)
	_smsMemberPrice.ID = field.NewInt(tableName, "id")
	_smsMemberPrice.SkuID = field.NewInt64(tableName, "sku_id")
	_smsMemberPrice.LevelID = field.NewInt64(tableName, "level_id")
	_smsMemberPrice.LevelName = field.NewString(tableName, "level_name")
	_smsMemberPrice.Price = field.NewInt64(tableName, "price")
	_smsMemberPrice.IsSuper = field.NewInt8(tableName, "is_super")

	_smsMemberPrice.fillFieldMap()

	return _smsMemberPrice
}

type smsMemberPrice struct {
	smsMemberPriceDo

	ALL       field.Asterisk
	ID        field.Int    // ID
	SkuID     field.Int64  // sku_id
	LevelID   field.Int64  // 会员等级
	LevelName field.String // 会员等级名
	Price     field.Int64  // 会员对应价格
	IsSuper   field.Int8   // 是否叠加优惠

	fieldMap map[string]field.Expr
}

func (s smsMemberPrice) Table(newTableName string) *smsMemberPrice {
	s.smsMemberPriceDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s smsMemberPrice) As(alias string) *smsMemberPrice {
	s.smsMemberPriceDo.DO = *(s.smsMemberPriceDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *smsMemberPrice) updateTableName(table string) *smsMemberPrice {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt(table, "id")
	s.SkuID = field.NewInt64(table, "sku_id")
	s.LevelID = field.NewInt64(table, "level_id")
	s.LevelName = field.NewString(table, "level_name")
	s.Price = field.NewInt64(table, "price")
	s.IsSuper = field.NewInt8(table, "is_super")

	s.fillFieldMap()

	return s
}

func (s *smsMemberPrice) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *smsMemberPrice) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 6)
	s.fieldMap["id"] = s.ID
	s.fieldMap["sku_id"] = s.SkuID
	s.fieldMap["level_id"] = s.LevelID
	s.fieldMap["level_name"] = s.LevelName
	s.fieldMap["price"] = s.Price
	s.fieldMap["is_super"] = s.IsSuper
}

func (s smsMemberPrice) clone(db *gorm.DB) smsMemberPrice {
	s.smsMemberPriceDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s smsMemberPrice) replaceDB(db *gorm.DB) smsMemberPrice {
	s.smsMemberPriceDo.ReplaceDB(db)
	return s
}

type smsMemberPriceDo struct{ gen.DO }

type ISmsMemberPriceDo interface {
	gen.SubQuery
	Debug() ISmsMemberPriceDo
	WithContext(ctx context.Context) ISmsMemberPriceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISmsMemberPriceDo
	WriteDB() ISmsMemberPriceDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISmsMemberPriceDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISmsMemberPriceDo
	Not(conds ...gen.Condition) ISmsMemberPriceDo
	Or(conds ...gen.Condition) ISmsMemberPriceDo
	Select(conds ...field.Expr) ISmsMemberPriceDo
	Where(conds ...gen.Condition) ISmsMemberPriceDo
	Order(conds ...field.Expr) ISmsMemberPriceDo
	Distinct(cols ...field.Expr) ISmsMemberPriceDo
	Omit(cols ...field.Expr) ISmsMemberPriceDo
	Join(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo
	Group(cols ...field.Expr) ISmsMemberPriceDo
	Having(conds ...gen.Condition) ISmsMemberPriceDo
	Limit(limit int) ISmsMemberPriceDo
	Offset(offset int) ISmsMemberPriceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISmsMemberPriceDo
	Unscoped() ISmsMemberPriceDo
	Create(values ...*model.SmsMemberPrice) error
	CreateInBatches(values []*model.SmsMemberPrice, batchSize int) error
	Save(values ...*model.SmsMemberPrice) error
	First() (*model.SmsMemberPrice, error)
	Take() (*model.SmsMemberPrice, error)
	Last() (*model.SmsMemberPrice, error)
	Find() ([]*model.SmsMemberPrice, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SmsMemberPrice, err error)
	FindInBatches(result *[]*model.SmsMemberPrice, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SmsMemberPrice) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISmsMemberPriceDo
	Assign(attrs ...field.AssignExpr) ISmsMemberPriceDo
	Joins(fields ...field.RelationField) ISmsMemberPriceDo
	Preload(fields ...field.RelationField) ISmsMemberPriceDo
	FirstOrInit() (*model.SmsMemberPrice, error)
	FirstOrCreate() (*model.SmsMemberPrice, error)
	FindByPage(offset int, limit int) (result []*model.SmsMemberPrice, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISmsMemberPriceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s smsMemberPriceDo) Debug() ISmsMemberPriceDo {
	return s.withDO(s.DO.Debug())
}

func (s smsMemberPriceDo) WithContext(ctx context.Context) ISmsMemberPriceDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s smsMemberPriceDo) ReadDB() ISmsMemberPriceDo {
	return s.Clauses(dbresolver.Read)
}

func (s smsMemberPriceDo) WriteDB() ISmsMemberPriceDo {
	return s.Clauses(dbresolver.Write)
}

func (s smsMemberPriceDo) Session(config *gorm.Session) ISmsMemberPriceDo {
	return s.withDO(s.DO.Session(config))
}

func (s smsMemberPriceDo) Clauses(conds ...clause.Expression) ISmsMemberPriceDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s smsMemberPriceDo) Returning(value interface{}, columns ...string) ISmsMemberPriceDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s smsMemberPriceDo) Not(conds ...gen.Condition) ISmsMemberPriceDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s smsMemberPriceDo) Or(conds ...gen.Condition) ISmsMemberPriceDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s smsMemberPriceDo) Select(conds ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s smsMemberPriceDo) Where(conds ...gen.Condition) ISmsMemberPriceDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s smsMemberPriceDo) Order(conds ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s smsMemberPriceDo) Distinct(cols ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s smsMemberPriceDo) Omit(cols ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s smsMemberPriceDo) Join(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s smsMemberPriceDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s smsMemberPriceDo) RightJoin(table schema.Tabler, on ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s smsMemberPriceDo) Group(cols ...field.Expr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s smsMemberPriceDo) Having(conds ...gen.Condition) ISmsMemberPriceDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s smsMemberPriceDo) Limit(limit int) ISmsMemberPriceDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s smsMemberPriceDo) Offset(offset int) ISmsMemberPriceDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s smsMemberPriceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISmsMemberPriceDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s smsMemberPriceDo) Unscoped() ISmsMemberPriceDo {
	return s.withDO(s.DO.Unscoped())
}

func (s smsMemberPriceDo) Create(values ...*model.SmsMemberPrice) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s smsMemberPriceDo) CreateInBatches(values []*model.SmsMemberPrice, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s smsMemberPriceDo) Save(values ...*model.SmsMemberPrice) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s smsMemberPriceDo) First() (*model.SmsMemberPrice, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SmsMemberPrice), nil
	}
}

func (s smsMemberPriceDo) Take() (*model.SmsMemberPrice, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SmsMemberPrice), nil
	}
}

func (s smsMemberPriceDo) Last() (*model.SmsMemberPrice, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SmsMemberPrice), nil
	}
}

func (s smsMemberPriceDo) Find() ([]*model.SmsMemberPrice, error) {
	result, err := s.DO.Find()
	return result.([]*model.SmsMemberPrice), err
}

func (s smsMemberPriceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SmsMemberPrice, err error) {
	buf := make([]*model.SmsMemberPrice, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s smsMemberPriceDo) FindInBatches(result *[]*model.SmsMemberPrice, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s smsMemberPriceDo) Attrs(attrs ...field.AssignExpr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s smsMemberPriceDo) Assign(attrs ...field.AssignExpr) ISmsMemberPriceDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s smsMemberPriceDo) Joins(fields ...field.RelationField) ISmsMemberPriceDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s smsMemberPriceDo) Preload(fields ...field.RelationField) ISmsMemberPriceDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s smsMemberPriceDo) FirstOrInit() (*model.SmsMemberPrice, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SmsMemberPrice), nil
	}
}

func (s smsMemberPriceDo) FirstOrCreate() (*model.SmsMemberPrice, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SmsMemberPrice), nil
	}
}

func (s smsMemberPriceDo) FindByPage(offset int, limit int) (result []*model.SmsMemberPrice, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s smsMemberPriceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s smsMemberPriceDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s smsMemberPriceDo) Delete(models ...*model.SmsMemberPrice) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *smsMemberPriceDo) withDO(do gen.Dao) *smsMemberPriceDo {
	s.DO = *do.(*gen.DO)
	return s
}
